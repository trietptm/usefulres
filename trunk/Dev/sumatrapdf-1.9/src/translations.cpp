/* Copyright 2006-2011 the SumatraPDF project authors (see AUTHORS file).
   License: GPLv3 */

#include "BaseUtil.h"
#include "translations.h"
#include "StrUtil.h"

namespace Trans {

/*
This code relies on the following variables that must be defined in 
the separate file translations_txt.cpp
The idea is that this file is automatically generated 
by a script from translation files.

// TODO: merge with gLangData(?)
// array of language codes so that gLangOrder[i] is a code of
// language. i is in 0 .. LANGS_COUNT-1
const char *gLangOrder[LANGS_COUNT];

// array of UTF-8 encoded translated strings. 
// it has LANGS_COUNT * STRINGS_COUNT elements
// (for simplicity). Translation i for language n is at position
// (n * STRINGS_COUNT) + i
const char *gTranslations[LANGS_COUNT * STRINGS_COUNT];

// array of language codes, names and IDs
// used for determining the human readable name of a language
// and for guessing the OS's current language settings
LangDef gLangData[LANGS_COUNT];
*/

#include "translations_txt.cpp"

// numeric index of the current language. 0 ... LANGS_COUNT-1
static int gCurrLangIdx = 0;
static const TCHAR **gTranslationCache = NULL;  // cached translations

const char *GuessLanguage()
{
    LANGID langId = GetUserDefaultUILanguage();
    LANGID langIdNoSublang = MAKELANGID(PRIMARYLANGID(langId), SUBLANG_NEUTRAL);
    const char *langCode = NULL;

    // Either find the exact primary/sub lang id match, or a neutral sublang if it exists
    // (don't return any sublang for a given language, it might be too different)
    for (int i = 0; i < LANGS_COUNT; i++) {
        if (langId == gLangData[i].id)
            return gLangData[i].code;

        if (langIdNoSublang == gLangData[i].id)
            langCode = gLangData[i].code;
        // continue searching after finding a match with a neutral sublanguage
    }

    return langCode;
}

static int GetLangOrderIndex(const char *code)
{
    for (size_t i = 0; i < dimof(gLangOrder); i++)
        if (str::Eq(code, gLangOrder[i]))
            return (int)i;
    return -1;
}

// checks whether the language code is known and returns
// a static pointer to the same code if so (else NULL)
const char *ConfirmLanguage(const char *code)
{
    int index = GetLangOrderIndex(code);
    if (0 <= index && index < LANGS_COUNT)
        return gLangOrder[index];
    return NULL;
}

bool SetCurrentLanguage(const char *code)
{
    int newIdx = GetLangOrderIndex(code);
    if (newIdx != -1)
        gCurrLangIdx = newIdx;
    return newIdx != -1;
}

static int cmpCharPtrs(const void *a, const void *b)
{
    return strcmp(*(char **)a, *(char **)b);
}

static int GetTranslationIndex(const char* txt)
{
    assert(gCurrLangIdx < LANGS_COUNT);
    const char **res = (const char **)bsearch(&txt, &gTranslations, STRINGS_COUNT, sizeof(gTranslations[0]), cmpCharPtrs);
    assert(res);
    if (!res) {
        // bad - didn't find a translation
        return -1;
    }

    return (int)(res - gTranslations);
}

// Call at program exit to free all memory related to translations functionality.
static int FreeData()
{
    if (!gTranslationCache)
        return 0;
    for (size_t i = 0; i < dimof(gTranslations); i++)
        free((void *)gTranslationCache[i]);
    free((void *)gTranslationCache);
    gTranslationCache = NULL;
    return 0;
}

// Return a properly encoded version of a translation for 'txt'.
// Memory for the string needs to be allocated and is cached in gTranslationCache
// array. That way the client doesn't have to worry about the lifetime of the string.
// All allocated strings can be freed with Trans::FreeData(), which should be
// done at program exit so that we're guaranteed no-one is using the data
const TCHAR *GetTranslation(const char *txt)
{
    if (!gTranslationCache) {
        assert(dimof(gTranslations) == STRINGS_COUNT * LANGS_COUNT);
        gTranslationCache = SAZA(const TCHAR *, dimof(gTranslations));
        if (!gTranslationCache)
            return _T("Missing translation!?");
        _onexit(FreeData);
    }

    int idx = GetTranslationIndex(txt);
    assert(0 <= idx && idx < STRINGS_COUNT);
    if (-1 == idx)
        return _T("Missing translation!?");

    int transIdx = (gCurrLangIdx * STRINGS_COUNT) + idx;
    // fall back to the English string, if a translation is missing
    if (!gTranslations[transIdx])
        transIdx = idx;

    if (!gTranslationCache[transIdx])
        gTranslationCache[transIdx] = str::conv::FromUtf8(gTranslations[transIdx]);
    return gTranslationCache[transIdx];
}

// returns an arbitrary index for a given language code
// which can be used for calling GetLanguageCode and
// GetLanguageName (this index isn't guaranteed to remain
// stable after a restart, use the language code when saving
// the current language settings instead)
int GetLanguageIndex(const char *code)
{
    if (!code)
        return -1;

    // optimize for the case where mostly only a single language is used
    static int ixCache = -1;
    if (ixCache != -1 && str::Eq(code, gLangData[ixCache].code))
        return ixCache;

    for (int i = 0; i < LANGS_COUNT; i++) {
        const char *langCode = gLangData[i].code;
        if (str::Eq(code, langCode))
            return (ixCache = i);
    }
    return -1;
}

// caller MUST NOT free the result
const char *GetLanguageCode(int index)
{
    assert(index >= 0);
    if (index < 0)
        return NULL;

    if (LANGS_COUNT <= index)
        return NULL;
    return gLangData[index].code;
}

// caller needs to free() the result
TCHAR *GetLanguageName(int index)
{
    assert(index >= 0);
    if (index < 0)
        return NULL;

    if (LANGS_COUNT <= index)
        return NULL;
    return str::conv::FromUtf8(gLangData[index].fullName);
}

bool IsLanguageRtL(int index)
{
    assert(index >= 0);
    if (index < 0)
        return false;

    if (LANGS_COUNT <= index)
        return NULL;
    return gLangData[index].isRTL != 0;
}

}
