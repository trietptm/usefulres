c++中，引用和指针的区别 收藏
                                                                指针和引用的区别

(1)引用总是指向一个对象,没有所谓的 null reference .所有当有可能指向一个对象也由可能不指向对象则必须使用 指针. 

由于C++ 要求 reference 总是指向一个对象所以 reference要求有初值. 

String & rs = string1; 

由于没有所谓的 null reference 所以所以在使用前不需要进行测试其是否有值.,而使用指针则需要测试其的有效性. 

(2)指针可以被重新赋值而reference则总是指向最初或地的对象. 

(3)必须使用reference的场合. Operator[] 操作符 由于该操作符很特别地必须返回 [能够被当做assignment 赋值对象] 的东西,所以需要给他返回一个 reference. 

(4)其实引用在函数的参数中使用很经常. 

void Get***(const int& a) //这样使用了引用有可以保证不修改被引用的值 

{ 

}

引用和指针

★ 相同点：
1. 都是地址的概念；
指针指向一块内存，它的内容是所指内存的地址；引用是某块内存的别名。

★ 区别：
1. 指针是一个实体，而引用仅是个别名；
2. 引用使用时无需解引用(*)，指针需要解引用；
3. 引用只能在定义时被初始化一次，之后不可变；指针可变；
引用“从一而终” ^_^
4. 引用没有 const，指针有 const，const 的指针不可变；
5. 引用不能为空，指针可以为空；
6. “sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身(所指向的变量或对象的地址)的大小；
typeid(T) == typeid(T&) 恒为真，sizeof(T) == sizeof(T&) 恒为真，
但是当引用作为成员时，其占用空间与指针相同（没找到标准的规定）。
7. 指针和引用的自增(++)运算意义不一样；

★ 联系
1. 引用在语言内部用指针实现（如何实现？）。
2. 对一般应用而言，把引用理解为指针，不会犯严重语义错误。引用是操作受限了的指针（仅容许取内容操作）。
引用是C++中的概念，初学者容易把引用和指针混淆一起。一下程序中，n 是m 的一 
个引用（reference），m 是被引用物（referent）。 
int m; 
int &n = m; 
n 相当于m 的别名（绰号），对n 的任何操作就是对m 的操作。例如有人名叫王小毛， 
他的绰号是“三毛”。说“三毛”怎么怎么的，其实就是对王小毛说三道四。所以n 既不 
是m 的拷贝，也不是指向m 的指针，其实n 就是m 它自己。 
引用的一些规则如下： 
（1）引用被创建的同时必须被初始化（指针则可以在任何时候被初始化）。 
（2）不能有NULL 引用，引用必须与合法的存储单元关联（指针则可以是NULL）。 
（3）一旦引用被初始化，就不能改变引用的关系（指针则可以随时改变所指的对象）。 
以下示例程序中，k 被初始化为i 的引用。语句k = j 并不能将k 修改成为j 的引 
用，只是把k 的值改变成为6。由于k 是i 的引用，所以i 的值也变成了6。 
int i = 5; 
int j = 6; 
int &k = i; 
k = j; // k 和i 的值都变成了6; 
上面的程序看起来象在玩文字游戏，没有体现出引用的价值。引用的主要功能是传 
递函数的参数和返回值。C++语言中，函数的参数和返回值的传递方式有三种：值传递、 
指针传递和引用传递。 
以下是“值传递”的示例程序。由于Func1 函数体内的x 是外部变量n 的一份拷贝， 
改变x 的值不会影响n, 所以n 的值仍然是0。 
void Func1(int x) 
{ 
x = x + 10; 
} 
int n = 0; 
Func1(n); 
cout << “n = ” << n << endl;// n = 0 
以下是“指针传递”的示例程序。由于Func2 函数体内的x 是指向外部变量n 的指 
针，改变该指针的内容将导致n 的值改变，所以n 的值成为10。 
void Func2(int *x) 
{ 
(* x) = (* x) + 10; 
} 
&#8943; 
int n = 0; 
Func2(&n); 
cout << “n = ” << n << endl; // n = 10 
以下是“引用传递”的示例程序。由于Func3 函数体内的x 是外部变量n 的引用，x 
和n 是同一个东西，改变x 等于改变n，所以n 的值成为10。 
void Func3(int &x) 
{ 
x = x + 10; 
} 
&#8943; 
int n = 0; 
Func3(n); 
cout << “n = ” << n << endl; // n = 10 
对比上述三个示例程序，会发现“引用传递”的性质象“指针传递”，而书写方式象 
“值传递”。实际上“引用”可以做的任何事情“指针”也都能够做，为什么还要“引用” 
这东西？ 
答案是“用适当的工具做恰如其分的工作”。 
指针能够毫无约束地操作内存中的如何东西，尽管指针功能强大，但是非常危险。 
就象一把刀，它可以用来砍树、裁纸、修指甲、理发等等，谁敢这样用？ 
如果的确只需要借用一下某个对象的“别名”，那么就用“引用”，而不要用“指针”， 
以免发生意外。比如说，某人需要一份证明，本来在文件上盖上公章的印子就行了，如 
果把取公章的钥匙交给他，那么他就获得了不该有的权利。 
－－－－－－－－－－ 
摘自『高质量c＋＋编程』
指针与引用，在More Effective C++ 的条款一有详细讲述，我给你转过来 
条款一：指针与引用的区别 
指针与引用看上去完全不同（指针用操作符’*’和’->’，引用使用操作符’.’），但是它们似乎有相同的功能。指针与引用都是让你间接引用其他对象。你如何决定在什么时候使用指针，在什么时候使用引用呢？ 
首先，要认识到在任何情况下都不能用指向空值的引用。一个引用必须总是指向某些对象。因此如果你使用一个变量并让它指向一个对象，但是该变量在某些时候也可能不指向任何对象，这时你应该把变量声明为指针，因为这样你可以赋空值给该变量。相反，如果变量肯定指向一个对象，例如你的设计不允许变量为空，这时你就可以把变量声明为引用。 
“但是，请等一下”，你怀疑地问，“这样的代码会产生什么样的后果？” 
char *pc = 0; // 设置指针为空值 
char& rc = *pc; // 让引用指向空值 
这是非常有害的，毫无疑问。结果将是不确定的（编译器能产生一些输出，导致任何事情都有可能发生），应该躲开写出这样代码的人除非他们同意改正错误。如果你担心这样的代码会出现在你的软件里，那么你最好完全避免使用引用，要不然就去让更优秀的程序员去做。我们以后将忽略一个引用指向空值的可能性。 
因为引用肯定会指向一个对象，在C里，引用应被初始化。 
string& rs; // 错误，引用必须被初始化 
string s("xyzzy"); 
string& rs = s; // 正确，rs指向s 
指针没有这样的限制。 
string *ps; // 未初始化的指针 
// 合法但危险 
不存在指向空值的引用这个事实意味着使用引用的代码效率比使用指针的要高。因为在使用引用之前不需要测试它的合法性。 
void printDouble(const double& rd) 
{ 
cout << rd; // 不需要测试rd,它 
} // 肯定指向一个double值 
相反，指针则应该总是被测试，防止其为空： 
void printDouble(const double *pd) 
{ 
if (pd) { // 检查是否为NULL 
cout << *pd; 
} 
} 
指针与引用的另一个重要的不同是指针可以被重新赋值以指向另一个不同的对象。但是引用则总是指向在初始化时被指定的对象，以后不能改变。 
string s1("Nancy"); 
string s2("Clancy"); 
string& rs = s1; // rs 引用 s1 
string *ps = &s1; // ps 指向 s1 
rs = s2; // rs 仍旧引用s1, 
// 但是 s1的值现在是 
// "Clancy" 
ps = &s2; // ps 现在指向 s2; 
// s1 没有改变 
总的来说，在以下情况下你应该使用指针，一是你考虑到存在不指向任何对象的可能（在这种情况下，你能够设置指针为空），二是你需要能够在不同的时刻指向不同的对象（在这种情况下，你能改变指针的指向）。如果总是指向一个对象并且一旦指向一个对象后就不会改变指向，那么你应该使用引用。 
还有一种情况，就是当你重载某个操作符时，你应该使用引用。最普通的例子是操作符[]。这个操作符典型的用法是返回一个目标对象，其能被赋值。 
vector<int> v(10); // 建立整形向量（vector），大小为10; 
// 向量是一个在标准C库中的一个模板(见条款35) 
v[5] = 10; // 这个被赋值的目标对象就是操作符[]返回的值 
如果操作符[]返回一个指针，那么后一个语句就得这样写： 
*v[5] = 10; 
但是这样会使得v看上去象是一个向量指针。因此你会选择让操作符返回一个引用。（这有一个有趣的例外，参见条款30） 
当你知道你必须指向一个对象并且不想改变其指向时，或者在重载操作符并为防止不必要的语义误解时，你不应该使用指针。而在除此之外的其他情况下，则应使用指针 
假设你有 
void func(int* p, int&r); 
int a = 1; 
int b = 1; 
func(&a,b); 
指针本身的值(地址值)是以pass by value进行的，你能改变地址值，但这并不会改变指针所指向的变量的值， 
p = someotherpointer; //a is still 1 
但能用指针来改变指针所指向的变量的值， 
*p = 123131; // a now is 123131 
但引用本身是以pass by reference进行的，改变其值即改变引用所对应的变量的值 
r = 1231; // b now is 1231